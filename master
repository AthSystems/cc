-- === Setup ===
local modem = peripheral.find("modem") or error("No modem found")
rednet.open(peripheral.getName(modem))

-- === Node IDs ===
local nodeDrills  = 0
local nodePusher  = 5
local nodeDeploy  = 20
local nodeDrawer  = 23
local nodeMonitor = 24

-- === Protocols ===
local ptc_control = "sky-control"
local ptc_reply   = "sky-reply"
local ptc_logs    = "sky-logs"
local ptc_status  = "sky-status"

-- === Keyword Messages ===
local kw_drills_forward     = "forward"
local kw_drills_backward    = "backward"
local kw_deploy             = "deploy"
local kw_lv_feedback        = "LVL"
local kw_lv_max             = "LVL 15"
local kw_lv_min             = "LVL 1"
local kw_drill_forward_ack  = "DFF"
local kw_drill_backward_ack = "DFB"
local kw_reset              = -15
local kw_ping               = "ping"
local kw_pong               = "pong"
local kw_stop               = "stop"
local kw_start              = "start"
local kw_fill               = "sky-fill" -- ⬅️ drawer % query keyword

-- === State ===
local pusher_lvl   = 1
local drill_state  = true
local manual_stop  = true
local drawer_stop  = false
local farm_running = false

-- === Config ===
local drawer_stop_threshold   = 90  -- Stop if >= 90%
local drawer_resume_threshold = 10  -- Resume if <= 10%

-- === Logging ===
local function logs(msg)
    print("[" .. os.date("%H:%M:%S") .. "] " .. msg)
    rednet.send(nodeMonitor, msg, ptc_logs)
end

-- === Messaging ===
local function send(id, msg)
    rednet.send(id, msg, ptc_control)
end

local function waitForReply(keyword)
    while true do
        local _, msg = rednet.receive()
        if msg and msg:find(keyword) then
            logs(msg)
            return tonumber(string.match(msg, kw_lv_feedback .. " ?(%d+)"))
        end
    end
end

local function waitForReplyWithTimeout(keyword, timeout)
    local start = os.clock()
    while os.clock() - start < timeout do
        local _, msg = rednet.receive(timeout)
        if msg and msg:find(keyword) then
            logs(msg)
            return tonumber(string.match(msg, kw_lv_feedback .. " ?(%d+)"))
        end
    end
    return nil
end

local function sendAndWait(id, msg, keyword)
    send(id, msg)
    return waitForReply(keyword)
end

local function pingNode(id, timeout)
    logs("Pinging node: " .. id)
    rednet.send(id, kw_ping, ptc_status)
    local start = os.clock()
    while os.clock() - start < timeout do
        local sender, msg, protocol = rednet.receive(ptc_reply, timeout)
        if sender == id and msg == kw_pong then
            logs("Node " .. id .. " responded.")
            return true
        end
    end
    logs("Node " .. id .. " did not respond.")
    return false
end

local function getDrawerPercent()
    rednet.send(nodeDrawer, kw_fill, ptc_control)
    local sender, msg, protocol = rednet.receive(ptc_status, 1)
    if sender == nodeDrawer then
        return tonumber(msg)
    end
    return nil
end

-- === Movement ===
local function move_drills(reverse)
    local cmd = reverse and kw_drills_backward or kw_drills_forward
    local ack = reverse and kw_drill_backward_ack or kw_drill_forward_ack
    sendAndWait(nodeDrills, cmd, ack)
    drill_state = not reverse
end

local function toggle_drills()
    move_drills(not drill_state)
end

local function deploy()
    sendAndWait(nodeDeploy, kw_deploy, "RD")
end

local function move_block_pusher(target)
    if target == 1 then
        send(nodePusher, 1)
        local lvl = waitForReply(pusher_lvl == 14 and kw_lv_max or kw_lv_feedback)
        pusher_lvl = lvl or pusher_lvl
    elseif target == 0 then
        local lvl = sendAndWait(nodePusher, kw_reset, kw_lv_min)
        pusher_lvl = lvl or pusher_lvl
    end
end

local function upward_plate_sequence_with_timeout()
    local timeout_duration = 20
    local last_feedback = os.clock()

    while pusher_lvl < 15 do
        send(nodePusher, 1)
        sleep(0.1)

        local lvl = waitForReplyWithTimeout(kw_lv_feedback, 3)
        if lvl then
            pusher_lvl = lvl
            last_feedback = os.clock()
            toggle_drills()
        elseif os.clock() - last_feedback >= timeout_duration then
            logs("No LVL feedback for 20s. Waiting drill end, retrying...")

            toggle_drills()
            waitForReply(drill_state and kw_drill_forward_ack or kw_drill_backward_ack)

            send(nodePusher, -1)
            local back_lvl = waitForReply(kw_lv_feedback)
            if back_lvl then pusher_lvl = back_lvl end

            toggle_drills()
            last_feedback = os.clock()
        end
    end
end

local function reset()
    move_block_pusher(0)
    if not drill_state then
        move_drills(true)
    end
    drill_state = true
end

local function stats_summary(start_time, fallback_count)
    logs("=== Cycle Stats ===")
    logs("Duration        : " .. string.format("%.1f", os.clock() - start_time) .. "s")
    logs("Final Plate LVL : " .. tostring(pusher_lvl))
    logs("Drill Direction : " .. (drill_state and "Forward" or "Backward"))
    logs("Fallback Retries: " .. tostring(fallback_count))
    logs("====================")
end

-- === Farm Cycle ===
local function farm_cycle()
    if farm_running then return end
    farm_running = true

    local start_time = os.clock()
    local fallback_count = 0

    logs("Starting new cycle.")
    deploy()
    sleep(6)

    local reached_lv5 = false
    while not reached_lv5 do
        local climb_start = os.clock()
        while os.clock() - climb_start < 7 do
            move_block_pusher(1)
            sleep(0.5)
            if pusher_lvl >= 5 then
                reached_lv5 = true
                break
            end
        end
        if not reached_lv5 then
            logs("Failed to reach LVL 5, retrying...")
            fallback_count = fallback_count + 1
            send(nodePusher, -1)
            sleep(1.5)
        end
    end

    logs("Reached LVL 5. Starting drill-assisted climb to LVL 15.")
    upward_plate_sequence_with_timeout()

    logs("Cycle complete. Resetting.")
    reset()
    stats_summary(start_time, fallback_count)
    logs("Farm ready.")
    farm_running = false
end

-- === Listener ===
local function listenControl()
    while true do
        local sender, msg, protocol = rednet.receive()
        if protocol == ptc_control then
            if msg == kw_stop and sender == nodeMonitor then
                manual_stop = true
                logs("Manual stop triggered.")
            elseif msg == kw_start and sender == nodeMonitor then
                manual_stop = false
                logs("Manual start triggered.")
            end
        end
    end
end

-- === Wait Button ===
local function waitManualStart()
    logs("Waiting for monitor start signal...")
    while manual_stop do sleep(0.5) end
end

-- === Init ===
logs("Pinging all nodes...")
for _, id in ipairs({ nodeDrills, nodePusher, nodeDeploy, nodeDrawer }) do
    pingNode(id, 4)
end

logs("Resetting system...")
reset()

-- === Main ===
parallel.waitForAny(
    listenControl,
    function()
        waitManualStart()
        while true do
            local percent = getDrawerPercent()
            if percent then
                if percent >= drawer_stop_threshold and not drawer_stop then
                    drawer_stop = true
                    logs("Drawer threshold reached (" .. percent .. "%). Auto-stop.")
                elseif percent <= drawer_resume_threshold and drawer_stop then
                    drawer_stop = false
                    logs("Drawer emptied (" .. percent .. "%). Auto-resume.")
                end
            end

            if not manual_stop and not drawer_stop and not farm_running then
                farm_cycle()
            end

            sleep(1)
        end
    end
)
