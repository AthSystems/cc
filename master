-- === Setup ===
local modem = peripheral.find("modem") or error("No modem found")
rednet.open(peripheral.getName(modem))

-- === Node IDs ===
local nodeDrills  = 0
local nodePusher  = 5
local nodeDeploy  = 20
local nodeDrawer  = 23
local nodeMonitor = 24

-- === Protocols ===
local ptc_control = "sky-control"
local ptc_reply   = "sky-reply"
local ptc_logs    = "sky-logs"
local ptc_status  = "sky-status"

-- === Keywords ===
local kw_drills_forward  = "forward"
local kw_drills_backward = "backward"
local kw_deploy          = "deploy"
local kw_sky_fill = "sky-fill"

-- === State ===
local pusher_lvl   = 1
local drill_state  = true
local manual_stop  = true
local drawer_stop  = false
local farm_running = false

-- === Config ===
local drawer_stop_threshold   = 90  -- Stop if >= 90%
local drawer_resume_threshold = 10  -- Resume only if < 10%

-- === Logging ===
local function logs(msg)
    print("[" .. os.date("%H:%M:%S") .. "] " .. msg)
    rednet.send(nodeMonitor, msg, ptc_logs)
end

-- === Messaging ===
local function send(id, msg)
    rednet.send(id, msg, ptc_control)
end

local function waitForReply(keyword)
    while true do
        local _, msg = rednet.receive()
        if msg and msg:find(keyword) then
            logs(msg)
            return tonumber(string.match(msg, "LVL ?(%d+)"))
        end
    end
end

local function waitForReplyWithTimeout(keyword, timeout)
    local start = os.clock()
    while os.clock() - start < timeout do
        local _, msg = rednet.receive(timeout)
        if msg and msg:find(keyword) then
            logs(msg)
            return tonumber(string.match(msg, "LVL ?(%d+)"))
        end
    end
    return nil
end

local function sendAndWait(id, msg, keyword)
    send(id, msg)
    return waitForReply(keyword)
end

local function pingNode(id, timeout)
    logs("Pinging node: " .. id)
    rednet.send(id, "ping", ptc_status)
    local start = os.clock()
    while os.clock() - start < timeout do
        local sender, msg, protocol = rednet.receive(ptc_reply, timeout)
        if sender == id and msg == "pong" then
            logs("Node " .. id .. " responded.")
            return true
        end
    end
    logs("Node " .. id .. " did not respond.")
    return false
end

local function getDrawerPercent()
    rednet.send(nodeDrawer, kw_fill, ptc_control)
    local sender, msg, protocol = rednet.receive(ptc_status, 1)
    if sender == nodeDrawer then
        return tonumber(msg)
    end
    return nil
end

-- === Movement ===
local function move_drills(reverse)
    local dir = reverse and kw_drills_backward or kw_drills_forward
    sendAndWait(nodeDrills, dir, reverse and "DFB" or "DFF")
    drill_state = not reverse
end

local function toggle_drills()
    move_drills(not drill_state)
end

local function deploy()
    sendAndWait(nodeDeploy, kw_deploy, "RD")
end

local function move_block_pusher(target)
    if target == 1 then
        send(nodePusher, 1)
        local lvl = waitForReply(pusher_lvl == 14 and "LVL 15" or "LVL")
        pusher_lvl = lvl or pusher_lvl
    elseif target == 0 then
        local lvl = sendAndWait(nodePusher, -15, "LVL 1")
        pusher_lvl = lvl or pusher_lvl
    end
end

local function upward_plate_sequence_with_timeout()
    local timeout_duration = 20
    local last_feedback = os.clock()

    while pusher_lvl < 15 do
        send(nodePusher, 1)
        sleep(0.1)

        local lvl = waitForReplyWithTimeout("LVL", 3)
        if lvl then
            pusher_lvl = lvl
            last_feedback = os.clock()
            toggle_drills()
        elseif os.clock() - last_feedback >= timeout_duration then
            logs("No LVL feedback for 20s. Waiting drill end, retrying...")

            toggle_drills()
            waitForReply(drill_state and "DFF" or "DFB")

            send(nodePusher, -1)
            local back_lvl = waitForReply("LVL")
            if back_lvl then pusher_lvl = back_lvl end

            toggle_drills()
            last_feedback = os.clock()
        end
    end
end

local function reset()
    move_block_pusher(0)
    if not drill_state then
        move_drills(true)
    end
    drill_state = true
end

local function stats_summary(start_time, fallback_count)
    logs("=== Cycle Stats ===")
    logs("Duration        : " .. string.format("%.1f", os.clock() - start_time) .. "s")
    logs("Final Plate LVL : " .. tostring(pusher_lvl))
    logs("Drill Direction : " .. (drill_state and "Forward" or "Backward"))
    logs("Fallback Retries: " .. tostring(fallback_count))
    logs("====================")
end

-- === Farm Cycle ===
local function farm_cycle()
    if farm_running then return end
    farm_running = true

    local start_time = os.clock()
    local fallback_count = 0

    logs("Starting new cycle.")
    deploy()
    sleep(6)

    -- Climb to LVL 5
    local reached_lv5 = false
    while not reached_lv5 do
        local climb_start = os.clock()
        while os.clock() - climb_start < 7 do
            move_block_pusher(1)
            sleep(0.5)
            if pusher_lvl >= 5 then
                reached_lv5 = true
                break
            end
        end
        if not reached_lv5 then
            logs("Failed to reach LVL 5, retrying...")
            fallback_count = fallback_count + 1
            send(nodePusher, -1)
            sleep(1.5)
        end
    end

    logs("Reached LVL 5. Starting upward climb with drills.")
    upward_plate_sequence_with_timeout()

    logs("Cycle finished. Resetting.")
    reset()
    stats_summary(start_time, fallback_count)
    logs("Farm ready for new cycle.")
    farm_running = false
end

-- === Listeners ===
local function listenControl()
    while true do
        local sender, msg, protocol = rednet.receive()
        if protocol == ptc_control then
            if msg == "stop" and sender == nodeMonitor then
                manual_stop = true
                logs("Manual stop triggered.")
            elseif msg == "start" and sender == nodeMonitor then
                manual_stop = false
                logs("Manual start triggered.")
            end
        end
    end
end

local function waitManualStart()
    logs("Waiting for START button on monitor...")
    while manual_stop do sleep(0.5) end
end

-- === Startup ===
logs("Pinging nodes...")
for _, id in ipairs({ nodeDrills, nodePusher, nodeDeploy, nodeDrawer }) do
    pingNode(id, 4)
end

logs("Resetting system...")
reset()

-- === Main Loop ===
parallel.waitForAny(
    listenControl,
    function()
        waitManualStart()
        while true do
            local percent = getDrawerPercent()
            if percent then
                if percent >= drawer_stop_threshold then
                    if not drawer_stop then
                        logs("Drawer filled (" .. percent .. "%) — auto-stop triggered.")
                        drawer_stop = true
                    end
                elseif percent <= drawer_resume_threshold then
                    if drawer_stop then
                        logs("Drawer cleared (" .. percent .. "%) — auto-resume allowed.")
                        drawer_stop = false
                    end
                end
            end

            if not manual_stop and not drawer_stop and not farm_running then
                farm_cycle()
            end

            sleep(1)
        end
    end
)
