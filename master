-- === Setup ===
local modem = peripheral.find("modem") or error("No modem found")
rednet.open(peripheral.getName(modem))

-- === Node IDs ===
local nodeDrills = 0
local nodePusher = 5
local nodeDeploy = 20
local nodeDrawer = 23
local nodeMonitor = 24

-- === Protocols ===
local kw_control = "sky-control"
local kw_reply   = "sky-reply"
local kw_logs    = "sky-logs"
local kw_status  = "sky-status"
local kw_fill    = "sky-fill"

-- === Commands / Keywords ===
local kw_drills_forward  = "forward"
local kw_drills_backward = "backward"
local kw_deploy          = "deploy"
local kw_ping            = "ping"
local kw_pong            = "pong"
local kw_stop            = "stop"
local kw_start           = "start"

-- === Fill Thresholds (%)
local stop_threshold = 90
local resume_threshold = 10

-- === State ===
local drill_state = true
local pusher_lvl = 1
local manual_stop = true
local drawer_stop = false
local farm_running = false

-- === Logging ===
local function logs(msg)
    print("[" .. os.date("%H:%M:%S") .. "] " .. msg)
    rednet.send(nodeMonitor, msg, kw_logs)
end

-- === Messaging Utilities ===
local function send(id, msg)
    rednet.send(id, msg, kw_control)
end

local function waitForReplyWithTimeout(keyword, timeout)
    local start = os.clock()
    while os.clock() - start < timeout do
        local _, msg = rednet.receive(timeout)
        if msg and msg:find(keyword) then
            logs(msg)
            local lvl = tonumber(msg:match("LVL ?(%d+)"))
            return msg, lvl
        end
    end
    return nil, nil
end

local function sendAndWait(id, msg, keyword)
    send(id, msg)
    return waitForReplyWithTimeout(keyword, 4)
end

local function pingNode(id, timeout)
    logs("Pinging node: " .. id)
    rednet.send(id, kw_ping, kw_status)
    local start = os.clock()
    while os.clock() - start < timeout do
        local sender, message, protocol = rednet.receive(kw_reply, timeout)
        if sender == id and message == kw_pong then
            logs("Node " .. id .. " responded.")
            return true
        end
    end
    logs("Node " .. id .. " did not respond.")
    return false
end

-- === Drawer Fill Query ===
local function get_drawer_fill()
    rednet.send(nodeDrawer, "query", kw_fill)
    local start = os.clock()
    while os.clock() - start < 2 do
        local id, msg, proto = rednet.receive(kw_fill, 2)
        if id == nodeDrawer and type(msg) == "table" and msg.percent then
            return msg.percent
        end
    end
    return nil
end

-- === Controls ===
local function move_drills(reverse)
    if reverse then
        sendAndWait(nodeDrills, kw_drills_backward, "DFB")
    else
        sendAndWait(nodeDrills, kw_drills_forward, "DFF")
    end
end

local function toggle_drills()
    move_drills(not drill_state)
    drill_state = not drill_state
end

local function deploy()
    sendAndWait(nodeDeploy, kw_deploy, "RD")
end

local function reset()
    send(nodePusher, -15)
    waitForReplyWithTimeout("LVL 1", 3)
    pusher_lvl = 1
    if not drill_state then
        move_drills(true)
        drill_state = true
    end
end

-- === Farm Logic ===
local function upward_sequence()
    local timeout_duration = 20
    local last_feedback = os.clock()

    while pusher_lvl < 15 do
        send(nodePusher, 1)
        sleep(0.1)
        local _, lvl = waitForReplyWithTimeout("LVL", 3)
        if lvl then
            pusher_lvl = lvl
            last_feedback = os.clock()
            toggle_drills()
        elseif os.clock() - last_feedback > timeout_duration then
            toggle_drills()
            waitForReplyWithTimeout(drill_state and "DFF" or "DFB", 10)
            send(nodePusher, -1)
            waitForReplyWithTimeout("LVL", 2)
            pusher_lvl = pusher_lvl - 1
            toggle_drills()
            last_feedback = os.clock()
        end
    end
end

local function farm_cycle()
    if farm_running or manual_stop or drawer_stop then return end
    farm_running = true
    local start_time = os.clock()
    local fallback_count = 0

    logs("Starting cycle")
    deploy()
    sleep(5)

    logs("Climbing to LVL 5")
    while pusher_lvl < 5 do
        send(nodePusher, 1)
        local _, lvl = waitForReplyWithTimeout("LVL", 2)
        if lvl then
            pusher_lvl = lvl
        else
            fallback_count = fallback_count + 1
            send(nodePusher, -1)
            waitForReplyWithTimeout("LVL", 2)
            pusher_lvl = pusher_lvl - 1
        end
        sleep(0.5)
    end

    logs("Reached LVL 5. Engaging drills.")
    upward_sequence()
    reset()

    logs(string.format("Cycle done (%.1fs) | Fallbacks: %d", os.clock() - start_time, fallback_count))
    farm_running = false
end

-- === Fill Check Loop ===
local function checkDrawerStatus()
    while true do
        local fill = get_drawer_fill()
        if fill then
            if fill >= stop_threshold then
                if not drawer_stop then
                    logs("Drawer fill ≥ 90%. Stopping farm.")
                    drawer_stop = true
                    rednet.send(nodeMonitor, kw_stop, kw_control)
                end
            elseif fill <= resume_threshold then
                if drawer_stop then
                    logs("Drawer fill ≤ 10%. Resuming farm.")
                    drawer_stop = false
                    rednet.send(nodeMonitor, kw_start, kw_control)
                end
            end
        end
        sleep(5)
    end
end

-- === Listen for Monitor Commands ===
local function listenControl()
    while true do
        local sender, msg, protocol = rednet.receive()
        if protocol == kw_control then
            if msg == kw_stop and sender == nodeMonitor then
                manual_stop = true
                logs("Manual stop triggered.")
            elseif msg == kw_start and sender == nodeMonitor then
                manual_stop = false
                logs("Manual start triggered.")
            end
        end
    end
end

-- === Launch System ===
logs("Pinging nodes...")
for _, id in ipairs({ nodeDrills, nodePusher, nodeDeploy, nodeDrawer }) do
    pingNode(id, 3)
end

reset()
logs("System ready. Waiting for start.")

parallel.waitForAny(
    listenControl,
    checkDrawerStatus,
    function()
        while true do
            if not manual_stop and not drawer_stop then
                farm_cycle()
            end
            sleep(0.5)
        end
    end
)
